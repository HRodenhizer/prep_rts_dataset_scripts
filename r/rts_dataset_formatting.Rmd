---
title: "RTS Dataset Formatting"
author: "Heidi Rodenhizer"
date: "`r Sys.Date()`"
output: html_document
---

# TODO

-  add AdjacentRTS column?
-  change required column to factor with 'required', 'derived', and 'optional'
-  calculate area in script? (update to derived in metadata?)

# Set-Up

```{r}
library(reticulate)
library(sf)
library(tidyverse)
source("./r/custom_functions.R")
```

## User-Defined Input

Before starting, copy your new shapefile into the input_data directory. It is preferred that your file use EPSG:3413 (WGS 84 / NSIDC Sea Ice Polar Stereographic North) as the coordinate system, but this script will perform the transformation if necessary.
Provide the file name of the new data:

```{r}
new_data_file <- 'rts_dataset_test_polygons_new.geojson'  # set this
new_data_filepath <- paste(
  'input_data',
  new_data_file,
  sep = '/')
```

Provide the names of any metadata fields in your new file that are not already in the official RTS Data Set (please check the list to ensure that the field has not been included previously) that you would like to be included in the compiled data set:

```{r}
# Provide new metatdata fields as a list of the character column names. If there are no new fields, leave the code assigning an empty vector.
# If your new file is a shapefile, also provide a list of the abbreviated names
# Example:
# new_fields <- c('CustomColumn1', 'CustomColumn2')
# Shapefile example:
# new_fields_abbreviated = c('CstmCl1', 'CstmCl2')
# new_fields <- c('CustomColumn1' = 'CstmCl1', 'CustomColumn2' = 'CstmCl2')
new_fields <- c()
```

Have you already created RTS centroid columns, or would you like them to be created within this script? Provide either TRUE, if the columns do not exist yet, or FALSE, if you have already created them:

```{r}
# Example: 
# calculate_centroid <- FALSE
calculate_centroid <- TRUE
```

Would you like your formatted new data to be output in its own file (in which case you will email the file of new features to us to merge with the compiled data set) or appended the compiled dataset (in which case you will commit your updated file to your forked github repository and create a pull request to add the file to the official github repository). Your decision here should mostly be based on your comfort with github. If you have no idea what the second half of that sentence means, please opt for the separate file and email it to us.

```{r}
# Example
# separate_file <- TRUE
separate_file <- TRUE
```


# Import Metadata Description File

```{r}
col_metadata <- read_csv('input_data/metadata_description.csv')

required_fields <- col_metadata |>
  filter(Required == TRUE) |>
  pull(FieldName)

optional_fields <- col_metadata |>
  filter(Required == FALSE) |>
  pull(FieldName)

all_fields <- c(required_fields, optional_fields, new_fields)
```


# Import Official and New RTS Data Files
If you get the error 'Error in `all_of()`: ! Can't subset columns that don't exist. âœ– Column `{required_column}` doesn't exist.', check to make sure that all of the required columns (except UID, and optionally CentroidLat and CentroidLon) and new columns are present and named correctly in your shapefile of new RTS features.

```{r}
rts_file <- 'rts_dataset_test_polygons_current.geojson'
rts_data_filepath <- paste(
  'input_data',
  rts_file,
  sep = '/'
  )

rts_data <- read_sf(rts_data_filepath) |>
  select(all_of(c(!!!required_fields)),
         any_of(c(!!!optional_fields)))
```

```{r}
new_data <- read_sf(new_data_filepath)

if (st_crs(new_data) != st_crs(3413)) {
  new_data <- st_transform(new_data, crs = 3413)
}

if (calculate_centroid) {
  
  new_data <- new_data |>
    bind_cols(
    st_coordinates(
      st_centroid(
        new_data
      ) |>
          st_transform('EPSG:4326')
    )
  ) |>
  rename(CentroidLat = Y, CentroidLon = X)
  
  if (str_detect(new_data_file, '\\.geojson')) {
    new_data <- new_data |>
      select(
        all_of(
          c(!!!required_fields[
            which(!required_fields %in% c('MergedRTS', 'StabilizedRTS', 'UID', 'ContributionDate'))
          ]
          )
        ),
        any_of(c(!!!optional_fields)),
        all_of(c(!!!new_fields)))
    
  } else if (str_detect(new_data_file, '\\.shp')) {
    new_data <- new_data |>
      select(
        all_of(
          c(!!!setNames(
            c('CentroidLat', 'CentroidLon', 'ReginNm', 'CretrLb', 'BasMpDt', 'BsMpSrc', 'BsMpRsl', 'TrnClss'),
            required_fields[
              which(!required_fields %in% c('MergedRTS', 'StabilizedRTS', 'UID', 'ContributionDate'))
            ]
          )
          )
        ),
        any_of(
          c(!!!setNames(
            c('StblRTS', 'MrgdRTS', 'Area'),
            optional_fields)
          )
        ),
        all_of(
          c(!!!setNames(
            new_fields_abbreviated,
            new_fields
          )))
        )
  }
  
  
} else if (!calculate_centroid) {
  
  if (str_detect(new_data_file, '\\.geojson')) {
  new_data <- read_sf(new_data_filepath) |>
    select(
      all_of(
        c(!!!required_fields[
          which(!required_fields %in% c('MergedRTS', 'StabilizedRTS', 'UID', 'ContributionDate'))
        ]
        )
      ),
      any_of(c(!!!optional_fields)),
      all_of(c(!!!new_fields)))
  } else if (str_detect(new_data_file, '\\.shp')) {
    new_data <- new_data |>
      select(
        all_of(
          c(!!!setNames(
            c('CntrdLt', 'CntrdLn', 'ReginNm', 'CretrLb', 'BasMpDt', 'BsMpSrc', 'BsMpRsl', 'TrnClss'),
            required_fields[
              which(!required_fields %in% c('MergedRTS', 'StabilizedRTS', 'UID', 'ContributionDate'))
            ]
          )
          )
        ),
        any_of(
          c(!!!setNames(
            c('StblRTS', 'MrgdRTS', 'Area'),
            optional_fields)
          )
        ),
        all_of(
          c(!!!setNames(
            new_fields_abbreviated,
            new_fields
          )))
        )
  }
  
}
```


# Check Metadata Format of New Data

```{r}
run_formatting_checks(new_data)
```


# Generate UIDs

Set seed for UID generation (R) by concatenating all required metadata columns (except UID) into a single string
```{r}
new_data <- new_data |>
  rowwise() |>
  mutate(
    seed = str_flatten(
      c(
        round(CentroidLat, 13),
        round(CentroidLon, 13),
        RegionName,
        CreatorLab,
        BaseMapDate,
        BaseMapSource,
        BaseMapResolution,
        TrainClass,
        LabelType
      )
    ),
    .after = TrainClass
  ) |>
  ungroup()

new_seeds <- pull(new_data, seed)
```

Generate UIDs (Python via reticulate package)
```{python}
import uuid
```

```{python}
new_uids = [str(uuid.uuid5(uuid.NAMESPACE_DNS, name = seed)) for seed in r.new_seeds]
r.new_uids = new_uids
```

Add UIDs to New RTS Data (R)
```{r}
new_data <- new_data |>
  mutate(UID = new_uids,
         .after = seed)
```

# Check for Intersections with RTS Data Set

Find intersecting RTS polygons from the official RTS data set and retrieve their UIDs. Create an empty column for the UIDs of polygons that have been repeated that will be manually populated.
```{r}
new_data <- new_data |>
  # If you get an error about st_crs(x) does not equal st_crs(y), please ensure that your shapefile coordinates system is EPSG:3413
  mutate(
    Intersections = map_chr(
      st_intersects(new_data,
                    rts_data,
                    sparse = TRUE),
      ~ str_flatten(.x, collapse = ',')
    ),
    AdjacentPolys = map_chr(
      st_touches(new_data,
                    rts_data,
                    sparse = TRUE),
      ~ str_flatten(.x, collapse = ',')
    ),
    Intersections = remove_adjacent_polys(Intersections, AdjacentPolys),
    .after = colnames(new_data)[length(which(colnames(new_data) != 'geometry'))]
  ) |>
  rowwise() |>
  mutate(
    Intersections = get_uids_by_index_string(Intersections, rts_data),
    .after = Intersections
  ) |>
  ungroup() |>
  select(-AdjacentPolys)

overlapping_data <- new_data |>
  filter(str_length(Intersections) > 0)

if (nrow(overlapping_data) > 0) {
  
  if (!'RepeatRTS' %in% colnames(overlapping_data)) {
    overlapping_data <- overlapping_data |>
      mutate(RepeatRTS = NA,
             .before = geometry)
  }
  if (!'MergedRTS' %in% colnames(overlapping_data)) {
    overlapping_data <- overlapping_data |>
      mutate(MergedRTS = NA,
             .before = geometry)
  }
  if (!'StabilizedRTS' %in% colnames(overlapping_data)) {
    overlapping_data <- overlapping_data |>
      mutate(StabilizedRTS = NA,
             .before = geometry)
  }
  
  overlapping_data <- overlapping_data |>
    mutate(AccidentalOverlap = NA,
           .before = geometry)
  
  print(overlapping_data)
  
  st_write(overlapping_data,
           paste('r_output',
                 paste0(
                   str_split(new_data_file, '\\.')[[1]][1],
                   '_overlapping_polygons.geojson'),
                 sep = '/'), 
         append = FALSE)
  
  print(paste('Overlapping polygons have been saved to', 
              paste('r_output',
                 paste0(
                   str_split(new_data_file, '\\.')[[1]][1],
                   '_overlapping_polygons.geojson'),
                 sep = '/')))
  
} else {
  print('There were no overlapping polygons. Proceed to the next code chunk without any manual editing.')
}
```

At this point, you will need to manually check all polygons with intersections against the polygons in the official RTS data set in your preferred GIS software and save the output to `r paste0(str_split(new_data_file, '\\.')[[1]][1], '_overlapping_polygons_edited.geojson')` (press Ctrl+Enter while cursor is in the preceding in-line code chunk to see the actual file name, rather than the code to produce the file name).  When possible/necessary, try to find imagery that matches the date of the intersecting polygons - this may require contacting the lab that did the original delineation.

Your job is to inspect each of the polygons listed in the 'Intersections' column compared to the new RTS feature and manually copy and paste the UIDs from the 'Intersections' column into the 'RepeatRTS', 'StabilizedRTS', 'MergedRTS', or 'AccidentalOverlap' based on the relationship between the two polygons.

- Paste the UID into the RepeatRTS column when the new RTS feature is the same RTS feature as the RTS feature in the 'Intersections' column, but was delineated at a different point in time, by a different lab at the same point in time, or from different imagery at the same point in time. The RTS feature is the same when it was the result of the same RTS initiation event.

- Paste the UID into the StabilizedRTS column when the RTS feature in the 'Intersections' column is a stabilized RTS scar as of the date of the imagery used in the new RTS delineations.

- Paste the UID into the MergedRTS column when multiple RTS features in the 'Intersections' column merged to form the new RTS feature.

- Paste the UID into the AccidentalOverlap column when inaccuracies in delineation of separate RTS features lead to overlap (e.g. features that are very close to each other and the polygons barely touch). 

When this is done, each of the UIDs in the Intersections column should have been copied into one (and only one) of the 'RepeatRTS', 'StabilizedRTS', or 'MergedRTS' columns.


# Load Manually Edited File and Join to New Data

Add the 'RepeatRTS', 'StabilizedRTS', 'MergedRTS', or 'AccidentalOverlap' columns that you just edited back into `new_data`.

```{r}
edited_file <- paste('r_output', 
                     paste0(
                       str_split(new_data_file, '\\.')[[1]][1], 
                       '_overlapping_polygons_edited.geojson'
                     ), 
                     sep = '/')

if (file.exists(edited_file)) {
  
  overlapping_data <- read_sf(edited_file) |>
    select(all_of(c(!!!required_fields[which(required_fields != 'ContributionDate')])),
           all_of(c(!!!optional_fields[
             which(optional_fields %in% c('StabilizedRTS', 'MergedRTS'))
           ])),
           any_of(c(!!!optional_fields[
             which(!optional_fields %in% c('StabilizedRTS', 'MergedRTS'))
           ])),
           all_of(c(!!!new_fields)),
           seed,
           Intersections = matches('^I.+t', ignore.case = FALSE),
           RepeatRTS = matches('^R.+RTS', ignore.case = FALSE),
           AccidentalOverlap = matches('Ac.+O', ignore.case = FALSE))

new_data <- new_data |>
  full_join(overlapping_data |>
              st_drop_geometry(),
            by = colnames(new_data |>
                             st_drop_geometry())) |>
  mutate(UID = case_when(is.na(RepeatRTS) ~ UID,
                          !is.na(RepeatRTS) ~ RepeatRTS)) |>
  select(!matches('geometry')) # doesn't actually remove geometry column, but makes sure it is the last column after the join

} else {
  new_data <- new_data |>
    mutate(RepeatRTS = NA,
           MergedRTS = NA,
           StabilizedRTS = NA,
           AccidentalOverlap = NA,
           .before = geometry)
  
  warning('No manually edited file has been imported. This is okay if there were no overlapping polygons, but is a problem otherwise.')
}
```

# Check for Intersections within New RTS Data Set

Intersections within the new data set are assumed to be repeat delineations of the same RTS feature. If this is not true (e.g. if you have delineated an old RTS scar and an active RTS feature on top of it), this code will not assign UIDs properly. In this case, please get in touch with us to determine how to proceed.

```{r}
new_data <- new_data %>%
  mutate(ContributionDate = format(Sys.time(), '%Y-%m-%d')) %>%
  mutate(
    idx = seq(1:nrow(new_data)),
    # get all intersections for each RTS feature (excluding itself)
    SelfIntersectionIndices = map_chr(
      st_intersects(x = new_data, remove_self = TRUE),
      ~ str_flatten(.x, collapse = ',')
    ),
    SelfAdjacentIndices = map_chr(
      st_touches(x = new_data, remove_self = TRUE),
      ~ str_flatten(.x, collapse = ',')
    ),
    SelfIntersectionIndices = case_when(
      str_length(SelfAdjacentIndices) > 0 ~ '',
      TRUE ~ SelfIntersectionIndices
        ),
    UID = case_when(
      str_length(
        SelfIntersectionIndices
      ) == 0 | UID == RepeatRTS ~ UID,
      str_length(
        SelfIntersectionIndices
      ) > 0 ~ get_earliest_uid(., 
                                idx,
                                SelfIntersectionIndices)
    ),
    .after = RepeatRTS
  ) |>
  select(-SelfAdjacentIndices)
```


# Check Completeness of Intersection Information

```{r}
check_intersection_info(new_data)
```


# Final Column Selection

```{r}
new_data <- new_data |>
  add_empty_columns(
    optional_fields[
      which(!optional_fields %in% c('StabilizedRTS', 'MergedRTS'))
    ]
  ) |>
  select(all_of(all_fields))
```

# Save Formatted File as a Shapefile

```{r}
if (separate_file) {
  st_write(new_data,
         paste('r_output', 
               paste0(
                 str_split(new_data_file, '\\.')[[1]][1], 
                 '_formatted.geojson'), 
               sep = '/'), 
         append = FALSE)
} else {
  
  rts_data <- rts_data |>
  add_empty_columns(
    names(new_fields)
    ) |>
  select(all_of(all_fields))
  
  updated_data <- rts_data |>
    rbind(new_data)
  
  st_write(updated_data,
         paste('r_output', 
               rts_file, 
               sep = '/'), 
         append = FALSE)
}

```

Now you are ready to submit `r ifelse(separate_file == TRUE, paste0(str_split(new_data_file, '\\.')[[1]][1], '_formatted.geojson'), rts_file)`!